// src/actions/createCoin.ts
import { zoraFactoryImplABI } from "@zoralabs/coins";
import {
  parseEventLogs
} from "viem";

// src/constants.ts
import { zoraFactoryImplAddress } from "@zoralabs/coins";
import { base } from "viem/chains";
var COIN_FACTORY_ADDRESS = zoraFactoryImplAddress["8453"];
var SUPERCHAIN_WETH_ADDRESS = "0x4200000000000000000000000000000000000006";
var USDC_WETH_POOLS_BY_CHAIN = {
  [base.id]: "0xd0b53D9277642d899DF5C87A3966A349A798F224"
};

// src/utils/validateClientNetwork.ts
import { base as base2, baseSepolia } from "viem/chains";
var validateClientNetwork = (publicClient) => {
  const clientChainId = publicClient?.chain?.id;
  if (clientChainId === base2.id) {
    return;
  }
  if (clientChainId === baseSepolia.id) {
    return;
  }
  throw new Error(
    "Client network needs to be base or baseSepolia for current coin deployments."
  );
};

// src/metadata/cleanAndValidateMetadataURI.ts
function cleanAndValidateMetadataURI(uri) {
  if (uri.startsWith("ipfs://")) {
    return uri.replace(
      "ipfs://",
      "https://magic.decentralized-content.com/ipfs/"
    );
  }
  if (uri.startsWith("ar://")) {
    return uri.replace("ar://", "http://arweave.net/");
  }
  if (uri.startsWith("data:")) {
    throw new Error("Data URIs are not supported");
  }
  if (uri.startsWith("http://") || uri.startsWith("https://")) {
    return uri;
  }
  throw new Error("Invalid metadata URI");
}

// src/metadata/validateMetadataJSON.ts
function validateURIString(uri) {
  if (typeof uri !== "string") {
    throw new Error("URI must be a string");
  }
  if (uri.startsWith("ipfs://")) {
    return true;
  }
  if (uri.startsWith("ar://")) {
    return true;
  }
  if (uri.startsWith("https://")) {
    return true;
  }
  if (uri.startsWith("data:")) {
    return true;
  }
  return false;
}
function validateMetadataJSON(metadata) {
  if (typeof metadata !== "object" || !metadata) {
    throw new Error("Metadata must be an object and exist");
  }
  if (typeof metadata.name !== "string") {
    throw new Error("Metadata name is required and must be a string");
  }
  if (typeof metadata.description !== "string") {
    throw new Error("Metadata description is required and must be a string");
  }
  if (typeof metadata.image === "string") {
    if (!validateURIString(metadata.image)) {
      throw new Error("Metadata image is not a valid URI");
    }
  } else {
    throw new Error("Metadata image is required and must be a string");
  }
  if ("animation_url" in metadata) {
    if (typeof metadata.animation_url !== "string") {
      throw new Error("Metadata animation_url, if provided, must be a string");
    }
    if (!validateURIString(metadata.animation_url)) {
      throw new Error("Metadata animation_url is not a valid URI");
    }
  }
  const content = "content" in metadata && metadata.content;
  if (content) {
    if (typeof content.uri !== "string") {
      throw new Error("If provided, content.uri must be a string");
    }
    if (!validateURIString(content.uri)) {
      throw new Error("If provided, content.uri must be a valid URI string");
    }
    if (typeof content.mime !== "string") {
      throw new Error("If provided, content.mime must be a string");
    }
  }
  return true;
}

// src/metadata/validateMetadataURIContent.ts
async function validateMetadataURIContent(metadataURI) {
  const cleanedURI = cleanAndValidateMetadataURI(metadataURI);
  const response = await fetch(cleanedURI);
  if (!response.ok) {
    throw new Error("Metadata fetch failed");
  }
  if (!["application/json", "text/plain"].includes(
    response.headers.get("content-type") ?? ""
  )) {
    throw new Error("Metadata is not a valid JSON or plain text response type");
  }
  const metadataJson = await response.json();
  return validateMetadataJSON(metadataJson);
}

// src/actions/createCoin.ts
async function createCoinCall({
  name,
  symbol,
  uri,
  owners,
  payoutRecipient,
  initialPurchaseWei = 0n,
  tickLower = -208200,
  platformReferrer = "0x0000000000000000000000000000000000000000"
}) {
  if (!owners) {
    owners = [payoutRecipient];
  }
  await validateMetadataURIContent(uri);
  const currency = "0x4200000000000000000000000000000000000006";
  return {
    abi: zoraFactoryImplABI,
    functionName: "deploy",
    address: COIN_FACTORY_ADDRESS,
    args: [
      payoutRecipient,
      owners,
      uri,
      name,
      symbol,
      platformReferrer,
      currency,
      tickLower,
      initialPurchaseWei
    ],
    value: initialPurchaseWei
  };
}
function getCoinCreateFromLogs(receipt) {
  const eventLogs = parseEventLogs({
    abi: zoraFactoryImplABI,
    logs: receipt.logs
  });
  return eventLogs.find((log) => log.eventName === "CoinCreated")?.args;
}
async function createCoin(call, walletClient, publicClient, options) {
  validateClientNetwork(publicClient);
  const createCoinRequest = await createCoinCall(call);
  const { request } = await publicClient.simulateContract({
    ...createCoinRequest,
    account: walletClient.account
  });
  if (request.gas) {
    request.gas = request.gas * BigInt(options?.gasMultiplier ?? 100) / 100n;
  }
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const deployment = getCoinCreateFromLogs(receipt);
  return {
    hash,
    receipt,
    address: deployment?.coin,
    deployment
  };
}

// src/actions/tradeCoin.ts
import { coinABI } from "@zoralabs/coins";
import {
  parseEther,
  zeroAddress,
  parseEventLogs as parseEventLogs2
} from "viem";
import { baseSepolia as baseSepolia2 } from "viem/chains";
async function simulateBuy({
  target,
  requestedOrderSize,
  publicClient
}) {
  const numberResult = await publicClient.simulateContract({
    address: target,
    abi: coinABI,
    functionName: "buy",
    args: [
      zeroAddress,
      requestedOrderSize,
      0n,
      // minAmountOut
      0n,
      // sqrtPriceLimitX96
      zeroAddress
      // tradeReferrer
    ],
    // We want to ensure that the multicall3 contract has enough ETH to buy in the simulation
    stateOverride: [
      {
        address: baseSepolia2.contracts.multicall3.address,
        balance: parseEther("10000000")
      }
    ]
  });
  const orderSize = numberResult.result[0];
  const amountOut = numberResult.result[1];
  return { orderSize, amountOut };
}
function tradeCoinCall({
  target,
  direction,
  args: {
    recipient,
    orderSize,
    minAmountOut = 0n,
    sqrtPriceLimitX96 = 0n,
    tradeReferrer = zeroAddress
  }
}) {
  return {
    abi: coinABI,
    functionName: direction,
    address: target,
    args: [
      recipient,
      orderSize,
      minAmountOut,
      sqrtPriceLimitX96,
      tradeReferrer
    ],
    value: direction === "buy" ? orderSize : 0n
  };
}
function getTradeFromLogs(receipt, direction) {
  const eventLogs = parseEventLogs2({
    abi: coinABI,
    logs: receipt.logs
  });
  if (direction === "buy") {
    return eventLogs.find((log) => log.eventName === "CoinBuy")?.args;
  }
  return eventLogs.find((log) => log.eventName === "CoinSell")?.args;
}
async function tradeCoin(params, walletClient, publicClient) {
  validateClientNetwork(publicClient);
  const { request } = await publicClient.simulateContract({
    ...tradeCoinCall(params),
    account: walletClient.account
  });
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const trade = getTradeFromLogs(receipt, params.direction);
  return {
    hash,
    receipt,
    trade
  };
}

// src/actions/getOnchainCoinDetails.ts
import { coinABI as coinABI2, iUniswapV3PoolABI } from "@zoralabs/coins";
import {
  erc20Abi,
  formatEther,
  isAddressEqual,
  zeroAddress as zeroAddress2
} from "viem";
async function getOnchainCoinDetails({
  coin,
  user = zeroAddress2,
  publicClient
}) {
  validateClientNetwork(publicClient);
  const [balance, pool, owners, payoutRecipient] = await publicClient.multicall(
    {
      contracts: [
        {
          address: coin,
          abi: coinABI2,
          functionName: "balanceOf",
          args: [user]
        },
        {
          address: coin,
          abi: coinABI2,
          functionName: "poolAddress"
        },
        {
          address: coin,
          abi: coinABI2,
          functionName: "owners"
        },
        {
          address: coin,
          abi: coinABI2,
          functionName: "payoutRecipient"
        }
      ],
      allowFailure: false
    }
  );
  const USDC_WETH_POOL = USDC_WETH_POOLS_BY_CHAIN[publicClient.chain?.id || 0];
  const [
    coinWethPoolSlot0,
    coinWethPoolToken0,
    coinReservesRaw,
    coinTotalSupply,
    wethReservesRaw,
    usdcWethSlot0
  ] = await publicClient.multicall({
    contracts: [
      {
        address: pool,
        abi: iUniswapV3PoolABI,
        functionName: "slot0"
      },
      {
        address: pool,
        abi: iUniswapV3PoolABI,
        functionName: "token0"
      },
      {
        address: coin,
        abi: erc20Abi,
        functionName: "balanceOf",
        args: [pool]
      },
      {
        address: coin,
        abi: coinABI2,
        functionName: "totalSupply"
      },
      {
        address: SUPERCHAIN_WETH_ADDRESS,
        abi: erc20Abi,
        functionName: "balanceOf",
        args: [pool]
      },
      {
        address: USDC_WETH_POOL ?? coin,
        abi: iUniswapV3PoolABI,
        functionName: "slot0"
      }
    ],
    allowFailure: false
  });
  const wethPriceInUsdc = USDC_WETH_POOL ? uniswapV3SqrtPriceToBigIntScaled(
    usdcWethSlot0.sqrtPriceX96,
    18,
    6,
    true,
    18
  ) : null;
  const coinPriceInWeth = uniswapV3SqrtPriceToBigIntScaled(
    coinWethPoolSlot0.sqrtPriceX96,
    18,
    18,
    isAddressEqual(coinWethPoolToken0, coin),
    18
  );
  const marketCap = coinPriceInWeth * coinTotalSupply / 10n ** 18n;
  const wethLiquidity = wethReservesRaw;
  const tokenLiquidity = coinReservesRaw * coinPriceInWeth / 10n ** 18n;
  return {
    balance,
    pool,
    owners,
    payoutRecipient,
    marketCap: convertEthOutput(marketCap, wethPriceInUsdc),
    liquidity: convertEthOutput(
      wethLiquidity + tokenLiquidity,
      wethPriceInUsdc
    ),
    poolState: coinWethPoolSlot0
  };
}
function convertEthOutput(amountETH, wethToUsdc) {
  return {
    eth: amountETH,
    ethDecimal: parseFloat(formatEther(amountETH)),
    usdc: wethToUsdc ? amountETH * wethToUsdc : null,
    usdcDecimal: wethToUsdc ? parseFloat(formatEther(amountETH * wethToUsdc / 10n ** 18n)) : null
  };
}
function uniswapV3SqrtPriceToBigIntScaled(sqrtPriceX96, token0Decimals, token1Decimals, isToken0Coin, scaleDecimals = 18) {
  const numerator = sqrtPriceX96 * sqrtPriceX96;
  const denominator = 2n ** 192n;
  const scaleFactor = 10n ** BigInt(scaleDecimals);
  let ratioScaled = numerator * scaleFactor / denominator;
  const decimalsDiff = BigInt(token0Decimals - token1Decimals);
  if (decimalsDiff > 0n) {
    ratioScaled *= 10n ** decimalsDiff;
  } else if (decimalsDiff < 0n) {
    ratioScaled /= 10n ** -decimalsDiff;
  }
  if (!isToken0Coin) {
    if (ratioScaled === 0n) {
      return 0n;
    }
    ratioScaled = scaleFactor * scaleFactor / ratioScaled;
  }
  return ratioScaled;
}

// src/actions/updateCoinURI.ts
import { coinABI as coinABI3 } from "@zoralabs/coins";
import {
  parseEventLogs as parseEventLogs3
} from "viem";
function updateCoinURICall({
  newURI,
  coin
}) {
  if (!newURI.startsWith("ipfs://")) {
    throw new Error("URI needs to be an ipfs:// prefix uri");
  }
  return {
    abi: coinABI3,
    address: coin,
    functionName: "setContractURI",
    args: [newURI]
  };
}
async function updateCoinURI(args, walletClient, publicClient) {
  validateClientNetwork(publicClient);
  const call = updateCoinURICall(args);
  const { request } = await publicClient.simulateContract({
    ...call,
    account: walletClient.account
  });
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const eventLogs = parseEventLogs3({ abi: coinABI3, logs: receipt.logs });
  const uriUpdated = eventLogs.find(
    (log) => log.eventName === "ContractURIUpdated"
  );
  return { hash, receipt, uriUpdated };
}

// src/actions/updatePayoutRecipient.ts
import { coinABI as coinABI4 } from "@zoralabs/coins";
import {
  parseEventLogs as parseEventLogs4
} from "viem";
function updatePayoutRecipientCall({
  newPayoutRecipient,
  coin
}) {
  return {
    abi: coinABI4,
    address: coin,
    functionName: "setPayoutRecipient",
    args: [newPayoutRecipient]
  };
}
async function updatePayoutRecipient(args, walletClient, publicClient) {
  validateClientNetwork(publicClient);
  const call = updatePayoutRecipientCall(args);
  const { request } = await publicClient.simulateContract({
    ...call,
    account: walletClient.account
  });
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const eventLogs = parseEventLogs4({ abi: coinABI4, logs: receipt.logs });
  const payoutRecipientUpdated = eventLogs.find(
    (log) => log.eventName === "CoinPayoutRecipientUpdated"
  );
  return { hash, receipt, payoutRecipientUpdated };
}

// src/client/client.gen.ts
import {
  createClient,
  createConfig
} from "@hey-api/client-fetch";
var client = createClient(
  createConfig({
    baseUrl: "https://api-sdk.zora.engineering/"
  })
);

// src/client/sdk.gen.ts
var getCoin = (options) => {
  return (options.client ?? client).get({
    url: "/coin",
    ...options
  });
};
var getCoinComments = (options) => {
  return (options.client ?? client).get({
    url: "/coinComments",
    ...options
  });
};
var getCoins = (options) => {
  return (options.client ?? client).get({
    url: "/coins",
    ...options
  });
};
var getExplore = (options) => {
  return (options.client ?? client).get({
    url: "/explore",
    ...options
  });
};
var getProfile = (options) => {
  return (options.client ?? client).get({
    url: "/profile",
    ...options
  });
};
var getProfileBalances = (options) => {
  return (options.client ?? client).get({
    url: "/profileBalances",
    ...options
  });
};

// src/api/api-key.ts
var apiKey;
function setApiKey(key) {
  apiKey = key;
}
function getApiKeyMeta() {
  if (!apiKey) {
    return {};
  }
  return {
    headers: {
      "api-key": apiKey
    }
  };
}

// src/api/queries.ts
var getCoin2 = async (query, options) => {
  return await getCoin({
    ...options,
    query,
    meta: getApiKeyMeta()
  });
};
var getCoins2 = async (query, options) => {
  return await getCoins({
    query: {
      coins: query.coins.map((coinData) => JSON.stringify(coinData))
    },
    meta: getApiKeyMeta(),
    ...options
  });
};
var getCoinComments2 = async (query, options) => {
  return await getCoinComments({
    query,
    meta: getApiKeyMeta(),
    ...options
  });
};
var getProfile2 = async (query, options) => {
  return await getProfile({
    query,
    meta: getApiKeyMeta(),
    ...options
  });
};
var getProfileBalances2 = async (query, options) => {
  return await getProfileBalances({
    query,
    meta: getApiKeyMeta(),
    ...options
  });
};

// src/api/explore.ts
var createExploreQuery = (query, listType, options) => getExplore({
  ...options,
  query: { ...query, listType },
  meta: getApiKeyMeta()
});
var getCoinsTopGainers = (query = {}, options) => createExploreQuery(query, "TOP_GAINERS", options);
var getCoinsTopVolume24h = (query = {}, options) => createExploreQuery(query, "TOP_VOLUME_24H", options);
var getCoinsMostValuable = (query = {}, options) => createExploreQuery(query, "MOST_VALUABLE", options);
var getCoinsNew = (query = {}, options) => createExploreQuery(query, "NEW", options);
var getCoinsLastTraded = (query = {}, options) => createExploreQuery(query, "LAST_TRADED", options);
var getCoinsLastTradedUnique = (query = {}, options) => createExploreQuery(query, "LAST_TRADED_UNIQUE", options);
export {
  cleanAndValidateMetadataURI,
  createCoin,
  createCoinCall,
  getCoin2 as getCoin,
  getCoinComments2 as getCoinComments,
  getCoinCreateFromLogs,
  getCoins2 as getCoins,
  getCoinsLastTraded,
  getCoinsLastTradedUnique,
  getCoinsMostValuable,
  getCoinsNew,
  getCoinsTopGainers,
  getCoinsTopVolume24h,
  getOnchainCoinDetails,
  getProfile2 as getProfile,
  getProfileBalances2 as getProfileBalances,
  getTradeFromLogs,
  setApiKey,
  simulateBuy,
  tradeCoin,
  tradeCoinCall,
  updateCoinURI,
  updateCoinURICall,
  updatePayoutRecipient,
  updatePayoutRecipientCall,
  validateMetadataJSON,
  validateMetadataURIContent
};
//# sourceMappingURL=index.js.map