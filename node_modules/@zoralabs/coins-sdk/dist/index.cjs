"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/actions/createCoin.ts
var _coins = require('@zoralabs/coins');


var _viem = require('viem');

// src/constants.ts

var _chains = require('viem/chains');
var COIN_FACTORY_ADDRESS = _coins.zoraFactoryImplAddress["8453"];
var SUPERCHAIN_WETH_ADDRESS = "0x4200000000000000000000000000000000000006";
var USDC_WETH_POOLS_BY_CHAIN = {
  [_chains.base.id]: "0xd0b53D9277642d899DF5C87A3966A349A798F224"
};

// src/utils/validateClientNetwork.ts

var validateClientNetwork = (publicClient) => {
  const clientChainId = _optionalChain([publicClient, 'optionalAccess', _ => _.chain, 'optionalAccess', _2 => _2.id]);
  if (clientChainId === _chains.base.id) {
    return;
  }
  if (clientChainId === _chains.baseSepolia.id) {
    return;
  }
  throw new Error(
    "Client network needs to be base or baseSepolia for current coin deployments."
  );
};

// src/metadata/cleanAndValidateMetadataURI.ts
function cleanAndValidateMetadataURI(uri) {
  if (uri.startsWith("ipfs://")) {
    return uri.replace(
      "ipfs://",
      "https://magic.decentralized-content.com/ipfs/"
    );
  }
  if (uri.startsWith("ar://")) {
    return uri.replace("ar://", "http://arweave.net/");
  }
  if (uri.startsWith("data:")) {
    throw new Error("Data URIs are not supported");
  }
  if (uri.startsWith("http://") || uri.startsWith("https://")) {
    return uri;
  }
  throw new Error("Invalid metadata URI");
}

// src/metadata/validateMetadataJSON.ts
function validateURIString(uri) {
  if (typeof uri !== "string") {
    throw new Error("URI must be a string");
  }
  if (uri.startsWith("ipfs://")) {
    return true;
  }
  if (uri.startsWith("ar://")) {
    return true;
  }
  if (uri.startsWith("https://")) {
    return true;
  }
  if (uri.startsWith("data:")) {
    return true;
  }
  return false;
}
function validateMetadataJSON(metadata) {
  if (typeof metadata !== "object" || !metadata) {
    throw new Error("Metadata must be an object and exist");
  }
  if (typeof metadata.name !== "string") {
    throw new Error("Metadata name is required and must be a string");
  }
  if (typeof metadata.description !== "string") {
    throw new Error("Metadata description is required and must be a string");
  }
  if (typeof metadata.image === "string") {
    if (!validateURIString(metadata.image)) {
      throw new Error("Metadata image is not a valid URI");
    }
  } else {
    throw new Error("Metadata image is required and must be a string");
  }
  if ("animation_url" in metadata) {
    if (typeof metadata.animation_url !== "string") {
      throw new Error("Metadata animation_url, if provided, must be a string");
    }
    if (!validateURIString(metadata.animation_url)) {
      throw new Error("Metadata animation_url is not a valid URI");
    }
  }
  const content = "content" in metadata && metadata.content;
  if (content) {
    if (typeof content.uri !== "string") {
      throw new Error("If provided, content.uri must be a string");
    }
    if (!validateURIString(content.uri)) {
      throw new Error("If provided, content.uri must be a valid URI string");
    }
    if (typeof content.mime !== "string") {
      throw new Error("If provided, content.mime must be a string");
    }
  }
  return true;
}

// src/metadata/validateMetadataURIContent.ts
async function validateMetadataURIContent(metadataURI) {
  const cleanedURI = cleanAndValidateMetadataURI(metadataURI);
  const response = await fetch(cleanedURI);
  if (!response.ok) {
    throw new Error("Metadata fetch failed");
  }
  if (!["application/json", "text/plain"].includes(
    _nullishCoalesce(response.headers.get("content-type"), () => ( ""))
  )) {
    throw new Error("Metadata is not a valid JSON or plain text response type");
  }
  const metadataJson = await response.json();
  return validateMetadataJSON(metadataJson);
}

// src/actions/createCoin.ts
async function createCoinCall({
  name,
  symbol,
  uri,
  owners,
  payoutRecipient,
  initialPurchaseWei = 0n,
  tickLower = -208200,
  platformReferrer = "0x0000000000000000000000000000000000000000"
}) {
  if (!owners) {
    owners = [payoutRecipient];
  }
  await validateMetadataURIContent(uri);
  const currency = "0x4200000000000000000000000000000000000006";
  return {
    abi: _coins.zoraFactoryImplABI,
    functionName: "deploy",
    address: COIN_FACTORY_ADDRESS,
    args: [
      payoutRecipient,
      owners,
      uri,
      name,
      symbol,
      platformReferrer,
      currency,
      tickLower,
      initialPurchaseWei
    ],
    value: initialPurchaseWei
  };
}
function getCoinCreateFromLogs(receipt) {
  const eventLogs = _viem.parseEventLogs.call(void 0, {
    abi: _coins.zoraFactoryImplABI,
    logs: receipt.logs
  });
  return _optionalChain([eventLogs, 'access', _3 => _3.find, 'call', _4 => _4((log) => log.eventName === "CoinCreated"), 'optionalAccess', _5 => _5.args]);
}
async function createCoin(call, walletClient, publicClient, options) {
  validateClientNetwork(publicClient);
  const createCoinRequest = await createCoinCall(call);
  const { request } = await publicClient.simulateContract({
    ...createCoinRequest,
    account: walletClient.account
  });
  if (request.gas) {
    request.gas = request.gas * BigInt(_nullishCoalesce(_optionalChain([options, 'optionalAccess', _6 => _6.gasMultiplier]), () => ( 100))) / 100n;
  }
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const deployment = getCoinCreateFromLogs(receipt);
  return {
    hash,
    receipt,
    address: _optionalChain([deployment, 'optionalAccess', _7 => _7.coin]),
    deployment
  };
}

// src/actions/tradeCoin.ts







async function simulateBuy({
  target,
  requestedOrderSize,
  publicClient
}) {
  const numberResult = await publicClient.simulateContract({
    address: target,
    abi: _coins.coinABI,
    functionName: "buy",
    args: [
      _viem.zeroAddress,
      requestedOrderSize,
      0n,
      // minAmountOut
      0n,
      // sqrtPriceLimitX96
      _viem.zeroAddress
      // tradeReferrer
    ],
    // We want to ensure that the multicall3 contract has enough ETH to buy in the simulation
    stateOverride: [
      {
        address: _chains.baseSepolia.contracts.multicall3.address,
        balance: _viem.parseEther.call(void 0, "10000000")
      }
    ]
  });
  const orderSize = numberResult.result[0];
  const amountOut = numberResult.result[1];
  return { orderSize, amountOut };
}
function tradeCoinCall({
  target,
  direction,
  args: {
    recipient,
    orderSize,
    minAmountOut = 0n,
    sqrtPriceLimitX96 = 0n,
    tradeReferrer = _viem.zeroAddress
  }
}) {
  return {
    abi: _coins.coinABI,
    functionName: direction,
    address: target,
    args: [
      recipient,
      orderSize,
      minAmountOut,
      sqrtPriceLimitX96,
      tradeReferrer
    ],
    value: direction === "buy" ? orderSize : 0n
  };
}
function getTradeFromLogs(receipt, direction) {
  const eventLogs = _viem.parseEventLogs.call(void 0, {
    abi: _coins.coinABI,
    logs: receipt.logs
  });
  if (direction === "buy") {
    return _optionalChain([eventLogs, 'access', _8 => _8.find, 'call', _9 => _9((log) => log.eventName === "CoinBuy"), 'optionalAccess', _10 => _10.args]);
  }
  return _optionalChain([eventLogs, 'access', _11 => _11.find, 'call', _12 => _12((log) => log.eventName === "CoinSell"), 'optionalAccess', _13 => _13.args]);
}
async function tradeCoin(params, walletClient, publicClient) {
  validateClientNetwork(publicClient);
  const { request } = await publicClient.simulateContract({
    ...tradeCoinCall(params),
    account: walletClient.account
  });
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const trade = getTradeFromLogs(receipt, params.direction);
  return {
    hash,
    receipt,
    trade
  };
}

// src/actions/getOnchainCoinDetails.ts







async function getOnchainCoinDetails({
  coin,
  user = _viem.zeroAddress,
  publicClient
}) {
  validateClientNetwork(publicClient);
  const [balance, pool, owners, payoutRecipient] = await publicClient.multicall(
    {
      contracts: [
        {
          address: coin,
          abi: _coins.coinABI,
          functionName: "balanceOf",
          args: [user]
        },
        {
          address: coin,
          abi: _coins.coinABI,
          functionName: "poolAddress"
        },
        {
          address: coin,
          abi: _coins.coinABI,
          functionName: "owners"
        },
        {
          address: coin,
          abi: _coins.coinABI,
          functionName: "payoutRecipient"
        }
      ],
      allowFailure: false
    }
  );
  const USDC_WETH_POOL = USDC_WETH_POOLS_BY_CHAIN[_optionalChain([publicClient, 'access', _14 => _14.chain, 'optionalAccess', _15 => _15.id]) || 0];
  const [
    coinWethPoolSlot0,
    coinWethPoolToken0,
    coinReservesRaw,
    coinTotalSupply,
    wethReservesRaw,
    usdcWethSlot0
  ] = await publicClient.multicall({
    contracts: [
      {
        address: pool,
        abi: _coins.iUniswapV3PoolABI,
        functionName: "slot0"
      },
      {
        address: pool,
        abi: _coins.iUniswapV3PoolABI,
        functionName: "token0"
      },
      {
        address: coin,
        abi: _viem.erc20Abi,
        functionName: "balanceOf",
        args: [pool]
      },
      {
        address: coin,
        abi: _coins.coinABI,
        functionName: "totalSupply"
      },
      {
        address: SUPERCHAIN_WETH_ADDRESS,
        abi: _viem.erc20Abi,
        functionName: "balanceOf",
        args: [pool]
      },
      {
        address: _nullishCoalesce(USDC_WETH_POOL, () => ( coin)),
        abi: _coins.iUniswapV3PoolABI,
        functionName: "slot0"
      }
    ],
    allowFailure: false
  });
  const wethPriceInUsdc = USDC_WETH_POOL ? uniswapV3SqrtPriceToBigIntScaled(
    usdcWethSlot0.sqrtPriceX96,
    18,
    6,
    true,
    18
  ) : null;
  const coinPriceInWeth = uniswapV3SqrtPriceToBigIntScaled(
    coinWethPoolSlot0.sqrtPriceX96,
    18,
    18,
    _viem.isAddressEqual.call(void 0, coinWethPoolToken0, coin),
    18
  );
  const marketCap = coinPriceInWeth * coinTotalSupply / 10n ** 18n;
  const wethLiquidity = wethReservesRaw;
  const tokenLiquidity = coinReservesRaw * coinPriceInWeth / 10n ** 18n;
  return {
    balance,
    pool,
    owners,
    payoutRecipient,
    marketCap: convertEthOutput(marketCap, wethPriceInUsdc),
    liquidity: convertEthOutput(
      wethLiquidity + tokenLiquidity,
      wethPriceInUsdc
    ),
    poolState: coinWethPoolSlot0
  };
}
function convertEthOutput(amountETH, wethToUsdc) {
  return {
    eth: amountETH,
    ethDecimal: parseFloat(_viem.formatEther.call(void 0, amountETH)),
    usdc: wethToUsdc ? amountETH * wethToUsdc : null,
    usdcDecimal: wethToUsdc ? parseFloat(_viem.formatEther.call(void 0, amountETH * wethToUsdc / 10n ** 18n)) : null
  };
}
function uniswapV3SqrtPriceToBigIntScaled(sqrtPriceX96, token0Decimals, token1Decimals, isToken0Coin, scaleDecimals = 18) {
  const numerator = sqrtPriceX96 * sqrtPriceX96;
  const denominator = 2n ** 192n;
  const scaleFactor = 10n ** BigInt(scaleDecimals);
  let ratioScaled = numerator * scaleFactor / denominator;
  const decimalsDiff = BigInt(token0Decimals - token1Decimals);
  if (decimalsDiff > 0n) {
    ratioScaled *= 10n ** decimalsDiff;
  } else if (decimalsDiff < 0n) {
    ratioScaled /= 10n ** -decimalsDiff;
  }
  if (!isToken0Coin) {
    if (ratioScaled === 0n) {
      return 0n;
    }
    ratioScaled = scaleFactor * scaleFactor / ratioScaled;
  }
  return ratioScaled;
}

// src/actions/updateCoinURI.ts




function updateCoinURICall({
  newURI,
  coin
}) {
  if (!newURI.startsWith("ipfs://")) {
    throw new Error("URI needs to be an ipfs:// prefix uri");
  }
  return {
    abi: _coins.coinABI,
    address: coin,
    functionName: "setContractURI",
    args: [newURI]
  };
}
async function updateCoinURI(args, walletClient, publicClient) {
  validateClientNetwork(publicClient);
  const call = updateCoinURICall(args);
  const { request } = await publicClient.simulateContract({
    ...call,
    account: walletClient.account
  });
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const eventLogs = _viem.parseEventLogs.call(void 0, { abi: _coins.coinABI, logs: receipt.logs });
  const uriUpdated = eventLogs.find(
    (log) => log.eventName === "ContractURIUpdated"
  );
  return { hash, receipt, uriUpdated };
}

// src/actions/updatePayoutRecipient.ts




function updatePayoutRecipientCall({
  newPayoutRecipient,
  coin
}) {
  return {
    abi: _coins.coinABI,
    address: coin,
    functionName: "setPayoutRecipient",
    args: [newPayoutRecipient]
  };
}
async function updatePayoutRecipient(args, walletClient, publicClient) {
  validateClientNetwork(publicClient);
  const call = updatePayoutRecipientCall(args);
  const { request } = await publicClient.simulateContract({
    ...call,
    account: walletClient.account
  });
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const eventLogs = _viem.parseEventLogs.call(void 0, { abi: _coins.coinABI, logs: receipt.logs });
  const payoutRecipientUpdated = eventLogs.find(
    (log) => log.eventName === "CoinPayoutRecipientUpdated"
  );
  return { hash, receipt, payoutRecipientUpdated };
}

// src/client/client.gen.ts



var _clientfetch = require('@hey-api/client-fetch');
var client = _clientfetch.createClient.call(void 0, 
  _clientfetch.createConfig.call(void 0, {
    baseUrl: "https://api-sdk.zora.engineering/"
  })
);

// src/client/sdk.gen.ts
var getCoin = (options) => {
  return (_nullishCoalesce(options.client, () => ( client))).get({
    url: "/coin",
    ...options
  });
};
var getCoinComments = (options) => {
  return (_nullishCoalesce(options.client, () => ( client))).get({
    url: "/coinComments",
    ...options
  });
};
var getCoins = (options) => {
  return (_nullishCoalesce(options.client, () => ( client))).get({
    url: "/coins",
    ...options
  });
};
var getExplore = (options) => {
  return (_nullishCoalesce(options.client, () => ( client))).get({
    url: "/explore",
    ...options
  });
};
var getProfile = (options) => {
  return (_nullishCoalesce(options.client, () => ( client))).get({
    url: "/profile",
    ...options
  });
};
var getProfileBalances = (options) => {
  return (_nullishCoalesce(options.client, () => ( client))).get({
    url: "/profileBalances",
    ...options
  });
};

// src/api/api-key.ts
var apiKey;
function setApiKey(key) {
  apiKey = key;
}
function getApiKeyMeta() {
  if (!apiKey) {
    return {};
  }
  return {
    headers: {
      "api-key": apiKey
    }
  };
}

// src/api/queries.ts
var getCoin2 = async (query, options) => {
  return await getCoin({
    ...options,
    query,
    meta: getApiKeyMeta()
  });
};
var getCoins2 = async (query, options) => {
  return await getCoins({
    query: {
      coins: query.coins.map((coinData) => JSON.stringify(coinData))
    },
    meta: getApiKeyMeta(),
    ...options
  });
};
var getCoinComments2 = async (query, options) => {
  return await getCoinComments({
    query,
    meta: getApiKeyMeta(),
    ...options
  });
};
var getProfile2 = async (query, options) => {
  return await getProfile({
    query,
    meta: getApiKeyMeta(),
    ...options
  });
};
var getProfileBalances2 = async (query, options) => {
  return await getProfileBalances({
    query,
    meta: getApiKeyMeta(),
    ...options
  });
};

// src/api/explore.ts
var createExploreQuery = (query, listType, options) => getExplore({
  ...options,
  query: { ...query, listType },
  meta: getApiKeyMeta()
});
var getCoinsTopGainers = (query = {}, options) => createExploreQuery(query, "TOP_GAINERS", options);
var getCoinsTopVolume24h = (query = {}, options) => createExploreQuery(query, "TOP_VOLUME_24H", options);
var getCoinsMostValuable = (query = {}, options) => createExploreQuery(query, "MOST_VALUABLE", options);
var getCoinsNew = (query = {}, options) => createExploreQuery(query, "NEW", options);
var getCoinsLastTraded = (query = {}, options) => createExploreQuery(query, "LAST_TRADED", options);
var getCoinsLastTradedUnique = (query = {}, options) => createExploreQuery(query, "LAST_TRADED_UNIQUE", options);




























exports.cleanAndValidateMetadataURI = cleanAndValidateMetadataURI; exports.createCoin = createCoin; exports.createCoinCall = createCoinCall; exports.getCoin = getCoin2; exports.getCoinComments = getCoinComments2; exports.getCoinCreateFromLogs = getCoinCreateFromLogs; exports.getCoins = getCoins2; exports.getCoinsLastTraded = getCoinsLastTraded; exports.getCoinsLastTradedUnique = getCoinsLastTradedUnique; exports.getCoinsMostValuable = getCoinsMostValuable; exports.getCoinsNew = getCoinsNew; exports.getCoinsTopGainers = getCoinsTopGainers; exports.getCoinsTopVolume24h = getCoinsTopVolume24h; exports.getOnchainCoinDetails = getOnchainCoinDetails; exports.getProfile = getProfile2; exports.getProfileBalances = getProfileBalances2; exports.getTradeFromLogs = getTradeFromLogs; exports.setApiKey = setApiKey; exports.simulateBuy = simulateBuy; exports.tradeCoin = tradeCoin; exports.tradeCoinCall = tradeCoinCall; exports.updateCoinURI = updateCoinURI; exports.updateCoinURICall = updateCoinURICall; exports.updatePayoutRecipient = updatePayoutRecipient; exports.updatePayoutRecipientCall = updatePayoutRecipientCall; exports.validateMetadataJSON = validateMetadataJSON; exports.validateMetadataURIContent = validateMetadataURIContent;
//# sourceMappingURL=index.cjs.map